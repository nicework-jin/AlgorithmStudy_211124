"""
https://programmers.co.kr/learn/courses/30/lessons/60057

정확성  테스트
테스트 1 〉	통과 (0.03ms, 10.2MB)
테스트 2 〉	통과 (0.41ms, 10.2MB)
테스트 3 〉	통과 (0.36ms, 10.2MB)
테스트 4 〉	통과 (0.03ms, 10.3MB)
테스트 5 〉	통과 (0.00ms, 10.2MB)
테스트 6 〉	통과 (0.05ms, 10.2MB)
테스트 7 〉	통과 (0.49ms, 10.3MB)
테스트 8 〉	통과 (0.47ms, 10.2MB)
테스트 9 〉	통과 (0.74ms, 10.2MB)
테스트 10 〉	통과 (3.61ms, 10.3MB)
테스트 11 〉	통과 (0.10ms, 10.2MB)
테스트 12 〉	통과 (0.10ms, 10.2MB)
테스트 13 〉	통과 (0.12ms, 10.2MB)
테스트 14 〉	통과 (0.81ms, 10.2MB)
테스트 15 〉	통과 (0.13ms, 10.3MB)
테스트 16 〉	통과 (0.01ms, 10.3MB)
테스트 17 〉	통과 (1.30ms, 10.2MB)
테스트 18 〉	통과 (1.26ms, 10.4MB)
테스트 19 〉	통과 (1.25ms, 10.3MB)
테스트 20 〉	통과 (3.17ms, 10.3MB)
테스트 21 〉	통과 (3.12ms, 10.3MB)
테스트 22 〉	통과 (2.98ms, 10.4MB)
테스트 23 〉	통과 (2.96ms, 10.2MB)
테스트 24 〉	통과 (2.69ms, 10.3MB)
테스트 25 〉	통과 (2.97ms, 10.3MB)
테스트 26 〉	통과 (3.13ms, 10.2MB)
테스트 27 〉	통과 (2.93ms, 10.3MB)
테스트 28 〉	통과 (0.02ms, 10.3MB)

조건
- 문자열을 잘라 압축한 문자열 중 가장 짧은 것의 길이를 리턴하라
1. 문자열을 1개 이상의 단위로 잘라서 압축
2. 알파벳은 소문자로만 구성됨

알고리즘
1. 최대로 많이 자를 수 있는 경우 문자열의 절반이므로 해당 길이만큼 탐색
2. 문자열이 같아서 압축이 가능한 경우 cnt 개수 증가
3. 문자열이 같지 않은 경우, 이전 cnt 개수만큼 숫자를 표시하고 문자열을 더함
4. 이전 문자열의 길이보다 작은 경우 정답 변경
"""
def solution(s):
    answer = len(s)
    # 1
    for i in range(1, len(s)//2 + 1):
        temp = ''
        cnt = 1
        for j in range(0, len(s), i):
            # 2: 문자열이 같아서 압축할 수 있음
            if s[j:j+i] == s[j+i:j+i+i]:
                cnt += 1
            else:
                # 3: 문자열이 같지 않은 경우 cnt 개수만큼 숫자를 표시하고 문자열을 붙임
                if cnt > 1:
                    temp += str(cnt)
                    cnt = 1
                    
                temp += s[j:j+i]
        # 4: 이전 문자열의 길이보다 작은 경우 정답 변경
        if answer > len(temp):
            answer = len(temp)
    return answer