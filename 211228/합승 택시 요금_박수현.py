"""
https://programmers.co.kr/learn/courses/30/lessons/72413

정확성  테스트
테스트 1 〉	통과 (0.06ms, 10.3MB)
테스트 2 〉	통과 (0.07ms, 10.3MB)
테스트 3 〉	통과 (0.05ms, 10.3MB)
테스트 4 〉	통과 (0.18ms, 10.3MB)
테스트 5 〉	통과 (0.57ms, 10.3MB)
테스트 6 〉	통과 (0.45ms, 10.3MB)
테스트 7 〉	통과 (0.62ms, 10.4MB)
테스트 8 〉	통과 (0.76ms, 10.2MB)
테스트 9 〉	통과 (1.16ms, 10.3MB)
테스트 10 〉	통과 (1.37ms, 10.3MB)
효율성  테스트
테스트 1 〉	통과 (152.97ms, 10.5MB)
테스트 2 〉	통과 (499.78ms, 11.1MB)
테스트 3 〉	통과 (1056.61ms, 11.5MB)
테스트 4 〉	통과 (1161.72ms, 11.5MB)
테스트 5 〉	통과 (1171.59ms, 11.5MB)
테스트 6 〉	통과 (1054.54ms, 11.5MB)
테스트 7 〉	통과 (1199.40ms, 14MB)
테스트 8 〉	통과 (1224.06ms, 14MB)
테스트 9 〉	통과 (1275.25ms, 13MB)
테스트 10 〉	통과 (1288.75ms, 13MB)
테스트 11 〉	통과 (1246.12ms, 12.9MB)
테스트 12 〉	통과 (1084.63ms, 12.9MB)
테스트 13 〉	통과 (1200.06ms, 12.8MB)
테스트 14 〉	통과 (1192.52ms, 12.8MB)
테스트 15 〉	통과 (1082.74ms, 12.9MB)
테스트 16 〉	통과 (1202.16ms, 11.4MB)
테스트 17 〉	통과 (1194.91ms, 11.5MB)
테스트 18 〉	통과 (1193.49ms, 11.3MB)
테스트 19 〉	통과 (1176.27ms, 11.6MB)
테스트 20 〉	통과 (1173.92ms, 11.8MB)
테스트 21 〉	통과 (1058.37ms, 11.8MB)
테스트 22 〉	통과 (1198.20ms, 12.8MB)
테스트 23 〉	통과 (1220.15ms, 12.8MB)
테스트 24 〉	통과 (1077.52ms, 12.9MB)
테스트 25 〉	통과 (1180.94ms, 11.1MB)
테스트 26 〉	통과 (1174.21ms, 11MB)
테스트 27 〉	통과 (1122.44ms, 10.7MB)
테스트 28 〉	통과 (1103.84ms, 10.5MB)
테스트 29 〉	통과 (148.98ms, 10.4MB)
테스트 30 〉	통과 (134.01ms, 10.4MB)

조건
- A, B 두 사람이 s에서 출발해서 각 도착지점까지 택시를 타고 갈 때,
최저 택시 요금을 계산해서 리턴하라

1. 합승 하지 않고 각자 이동하는게 더 저렴하다면 합승하지 않아도 됨
2. 3 <= 지점 개수 <=200
3. s: 출발, a: 도착, b: 도착은 서로 겹치지 않음

알고리즘
- 플로이드 와샬 또는 다익스트라 알고리즘을 사용해서 풀 수 있는 그래프 문제
원리:
A->B의 최단 거리를 찾기 위해 경로 사이에 중간점을 끼워 넣는다.
직접 가는 것보다 짧은 경로가 있다면 그 거리로 원래 거리를 갱신한다.
예) A->B VS A->C->B VS A->D->B

다익스트라: 한 노드로부터 다른 노드까지의 최단 거리 찾기(1차원 거리 행렬)
플로이드 와샬: 모든 노드로부터 다른 노드까지의 최단 거리 찾기(2차원 거리 행렬)

풀이에 사용된 알고리즘 = 플로이드 와샬
1. 행렬의 값을 최대값으로 초기화하고 자신으로 향하는 간선은 0으로 초기화한다.
2. 거리 행렬에 주어진 비용을 그래프에 추가
3. 모든 노드를 중간 경로로 가정함
4. 거리 행렬을 순회한다.
5. 현재 거리 행렬에 저장된 거리가 3의 중간 거리를 거치는 것보다 멀면 갱신
6. 출발점을 기준으로 k를 거치는 지점 중 각 a, b로 가는 최소 비용을 탐색한다.
"""
from math import inf


def solution(n, s, a, b, fares):
    # 인덱스는 0부터 시작하기 때문에
    s, a, b = s - 1, a - 1, b - 1

    # 1. 행렬의 값을 최대값으로 초기화하고 자신으로 향하는 간선은 0으로 초기화한다.
    graph = [[inf] * n for _ in range(n)]
    for i in range(n):
        graph[i][i] = 0     

    # 2. 거리 행렬에 주어진 비용을 그래프에 추가
    for fare in fares:
        u, v, w = fare
        graph[u - 1][v - 1] = graph[v - 1][u - 1] = w

    # 플로이드-와샬
    for k in range(n):          # 3. 모든 노드를 중간 경로로 가정함
        for i in range(n):      # 4. 거리행렬을 순회
            for j in range(n):
							# 5. 현재 거리 행렬에 저장된 거리가 3의 중간 거리를 거치는 것보다 멀면 갱신
                if graph[i][j] > graph[i][k] + graph[k][j]:
                    graph[i][j] = graph[i][k] + graph[k][j]

		# 6. 출발점을 기준으로 k를 거치는 지점 중 각 a, b로 가는 최소 비용을 탐색한다.
    answer = inf
    for k in range(n):
        ans = min(ans, graph[s][k] + graph[k][a] + graph[k][b])

    return answer